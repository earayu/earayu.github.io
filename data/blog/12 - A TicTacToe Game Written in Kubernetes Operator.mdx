---
title: A TicTacToe Game Written in Kubernetes Operator (Part 1) (Draft)
date: '2024-01-14'
tags: ['kubernetes', 'operator', 'code for fun']
draft: true
summary: I am learning kubernetes, so I write a TicTacToe game based on Kubernetes Operator. This is a sample project to demonstrate how to build a Kubernetes Operator with Kubebuilder.
---

I've been a light user of Kubernetes for about half a year now.I'm familiar with kubectl, the declarative APIs, and the architecture of Kubernetes.
Whenever people talk about Kubernetes, they can't help but praise its declarative APIs and the Controller Loop.
It's fascinating when you think about it: you submit a YAML file to Kubernetes, and it orchestrates the desired state effortlessly.
This sparked my curiosity about the Controller Loopâ€”how does it precisely work?
To quench this thirst for knowledge, I've embarked on a journey to write a Kubernetes operator, and here's what I've learned.


## What is a Kubernetes Operator?
> short answer: Kubernetes Operator ==  CRD + Controller

![image.png](/assets/tictactoe/operator.png)
Think about when you submit a Deployment YAML file to Kubernetes, it creates a Deployment object in the cluster.
If some of the pods in the Deployment fail, Kubernetes will automatically restart them.
This is because Kubernetes has a built-in controller for the Deployment object.

See the pattern here? <br/>
Deployment is an API, and Kubernetes has a built-in controller for it.

Kubernetes allows us to define our own APIs (we call it CRD) and controllers, together they are called Kubernetes Operators.

So our problem next is: <br/>
* how to define our own APIs (CRD) ?
* how to write our own controllers ?

## How to Write a Kubernetes Operator in 2024?
Extending Kubernetes with CRD and Controllers is messy and complicated. Because we need to write a lot of boilerplate code.
Luckily, The year 2024 has brought us many tools to write a Kubernetes Operator. Among these, Kubebuilder is the most popular one.
Kubebuilder can help us scaffold out the boilerplate code for our operator.

### Creating a New API
To kick things off, we need to create a new project for our operator.
```
mkdir kube-kic-tac-toe
cd kube-kic-tac-toe
kubebuilder init --domain earayu.github.io --repo earayu.github.io/kube-kic-tac-toe
```
Then we can create a new API for our game. This is done using the Kubebuilder CLI.
We define a new custom resource definition (CRD) for our game with the following commands:
```
# choose YES when asked to whether create a resource or controller
kubebuilder create api --group earayu.github.io --version v1alpha1 --kind TicTacToe
kubebuilder create api --group earayu.github.io --version v1alpha1 --kind Move
```
These commands scaffold out our new TicTacToe and Move kinds, setting up the foundation for us to define the rules and logic of our game.
The TicTacToe kind could represent the game board, whereas Move could represent a player's move.

After we define our CRD, kubebuilder will generate the code for us. And the project structure will look like this:
![image.png](/assets/tictactoe/project.png)

### Creating a New Controller
Since we choose YES when asked to whether create a controller, kubebuilder will also generate a controller for us. You can see the generated code in the `internal/controllers/` directory.
As a operator developer, we only need to focus on the business logic of our controller.
```go
func (r *TicTacToeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {

}

func (r *MoveReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {

}
```


